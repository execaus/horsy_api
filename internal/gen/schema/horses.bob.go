// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package schema

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/google/uuid"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Horse is an object representing the database table.
type Horse struct {
	// Уникальный идентификатор лошади
	ID uuid.UUID `db:"id,pk" `
	// Идентификатор табуна, к которому принадлежит лошадь
	Herd uuid.UUID `db:"herd" `
	// Пол лошади
	Gender null.Val[uuid.UUID] `db:"gender" `
	// Имя лошади
	Name null.Val[string] `db:"name" `
	// День рождения лошади
	BirthDay null.Val[int32] `db:"birth_day" `
	// Месяц рождения лошади
	BirthMonth null.Val[int32] `db:"birth_month" `
	// Год рождения лошади
	BirthYear null.Val[int32] `db:"birth_year" `
	// Место рождения лошади
	BirthPlace null.Val[uuid.UUID] `db:"birth_place" `
	// Высота в холке (в сантиметрах)
	WithersHeight null.Val[int32] `db:"withers_height" `
	// Идентификатор отца (жеребца)
	Sire null.Val[uuid.UUID] `db:"sire" `
	// Идентификатор матери (кобылы)
	Dam null.Val[uuid.UUID] `db:"dam" `
	// Статус беременности (true, если беременна)
	IsPregnant bool `db:"is_pregnant" `
	// Статус лошади (true, если мертва)
	IsDead bool `db:"is_dead" `
	// Описание лошади
	Description null.Val[string] `db:"description" `
	// Время создания записи
	CreatedAt time.Time `db:"created_at" `
	// Время последнего обновления записи
	UpdatedAt time.Time `db:"updated_at" `

	R horseR `db:"-" `
}

// HorseSlice is an alias for a slice of pointers to Horse.
// This should almost always be used instead of []*Horse.
type HorseSlice []*Horse

// Horses contains methods to work with the horses table
var Horses = psql.NewTablex[*Horse, HorseSlice, *HorseSetter]("", "horses", buildHorseColumns("horses"))

// HorsesQuery is a query on the horses table
type HorsesQuery = *psql.ViewQuery[*Horse, HorseSlice]

// horseR is where relationships are stored.
type horseR struct {
	HorseBreeds          HorseBreedSlice    // horse_breed.fk_horse_breeds_horse
	Colors               ColorSlice         // horse_color.fk_horse_colors_colorhorse_color.fk_horse_colors_horse
	GeneticMarkers       GeneticMarkerSlice // horse_genetic_marker.fk_horse_genetic_marker_horsehorse_genetic_marker.fk_horse_genetic_marker_marker
	BirthPlaceBirthplace *Birthplace        // horses.fk_birth_place
	Gender               *Gender            // horses.fk_gender
	Dam                  *Horse             // horses.fk_recursive_dam
	ReverseDams          HorseSlice         // horses.fk_recursive_dam__self_join_reverse
	Sire                 *Horse             // horses.fk_recursive_sire
	ReverseSires         HorseSlice         // horses.fk_recursive_sire__self_join_reverse
}

func buildHorseColumns(alias string) horseColumns {
	return horseColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "herd", "gender", "name", "birth_day", "birth_month", "birth_year", "birth_place", "withers_height", "sire", "dam", "is_pregnant", "is_dead", "description", "created_at", "updated_at",
		).WithParent("horses"),
		tableAlias:    alias,
		ID:            psql.Quote(alias, "id"),
		Herd:          psql.Quote(alias, "herd"),
		Gender:        psql.Quote(alias, "gender"),
		Name:          psql.Quote(alias, "name"),
		BirthDay:      psql.Quote(alias, "birth_day"),
		BirthMonth:    psql.Quote(alias, "birth_month"),
		BirthYear:     psql.Quote(alias, "birth_year"),
		BirthPlace:    psql.Quote(alias, "birth_place"),
		WithersHeight: psql.Quote(alias, "withers_height"),
		Sire:          psql.Quote(alias, "sire"),
		Dam:           psql.Quote(alias, "dam"),
		IsPregnant:    psql.Quote(alias, "is_pregnant"),
		IsDead:        psql.Quote(alias, "is_dead"),
		Description:   psql.Quote(alias, "description"),
		CreatedAt:     psql.Quote(alias, "created_at"),
		UpdatedAt:     psql.Quote(alias, "updated_at"),
	}
}

type horseColumns struct {
	expr.ColumnsExpr
	tableAlias    string
	ID            psql.Expression
	Herd          psql.Expression
	Gender        psql.Expression
	Name          psql.Expression
	BirthDay      psql.Expression
	BirthMonth    psql.Expression
	BirthYear     psql.Expression
	BirthPlace    psql.Expression
	WithersHeight psql.Expression
	Sire          psql.Expression
	Dam           psql.Expression
	IsPregnant    psql.Expression
	IsDead        psql.Expression
	Description   psql.Expression
	CreatedAt     psql.Expression
	UpdatedAt     psql.Expression
}

func (c horseColumns) Alias() string {
	return c.tableAlias
}

func (horseColumns) AliasedAs(alias string) horseColumns {
	return buildHorseColumns(alias)
}

// HorseSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type HorseSetter struct {
	ID            omit.Val[uuid.UUID]     `db:"id,pk" `
	Herd          omit.Val[uuid.UUID]     `db:"herd" `
	Gender        omitnull.Val[uuid.UUID] `db:"gender" `
	Name          omitnull.Val[string]    `db:"name" `
	BirthDay      omitnull.Val[int32]     `db:"birth_day" `
	BirthMonth    omitnull.Val[int32]     `db:"birth_month" `
	BirthYear     omitnull.Val[int32]     `db:"birth_year" `
	BirthPlace    omitnull.Val[uuid.UUID] `db:"birth_place" `
	WithersHeight omitnull.Val[int32]     `db:"withers_height" `
	Sire          omitnull.Val[uuid.UUID] `db:"sire" `
	Dam           omitnull.Val[uuid.UUID] `db:"dam" `
	IsPregnant    omit.Val[bool]          `db:"is_pregnant" `
	IsDead        omit.Val[bool]          `db:"is_dead" `
	Description   omitnull.Val[string]    `db:"description" `
	CreatedAt     omit.Val[time.Time]     `db:"created_at" `
	UpdatedAt     omit.Val[time.Time]     `db:"updated_at" `
}

func (s HorseSetter) SetColumns() []string {
	vals := make([]string, 0, 16)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.Herd.IsValue() {
		vals = append(vals, "herd")
	}
	if !s.Gender.IsUnset() {
		vals = append(vals, "gender")
	}
	if !s.Name.IsUnset() {
		vals = append(vals, "name")
	}
	if !s.BirthDay.IsUnset() {
		vals = append(vals, "birth_day")
	}
	if !s.BirthMonth.IsUnset() {
		vals = append(vals, "birth_month")
	}
	if !s.BirthYear.IsUnset() {
		vals = append(vals, "birth_year")
	}
	if !s.BirthPlace.IsUnset() {
		vals = append(vals, "birth_place")
	}
	if !s.WithersHeight.IsUnset() {
		vals = append(vals, "withers_height")
	}
	if !s.Sire.IsUnset() {
		vals = append(vals, "sire")
	}
	if !s.Dam.IsUnset() {
		vals = append(vals, "dam")
	}
	if s.IsPregnant.IsValue() {
		vals = append(vals, "is_pregnant")
	}
	if s.IsDead.IsValue() {
		vals = append(vals, "is_dead")
	}
	if !s.Description.IsUnset() {
		vals = append(vals, "description")
	}
	if s.CreatedAt.IsValue() {
		vals = append(vals, "created_at")
	}
	if s.UpdatedAt.IsValue() {
		vals = append(vals, "updated_at")
	}
	return vals
}

func (s HorseSetter) Overwrite(t *Horse) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.Herd.IsValue() {
		t.Herd = s.Herd.MustGet()
	}
	if !s.Gender.IsUnset() {
		t.Gender = s.Gender.MustGetNull()
	}
	if !s.Name.IsUnset() {
		t.Name = s.Name.MustGetNull()
	}
	if !s.BirthDay.IsUnset() {
		t.BirthDay = s.BirthDay.MustGetNull()
	}
	if !s.BirthMonth.IsUnset() {
		t.BirthMonth = s.BirthMonth.MustGetNull()
	}
	if !s.BirthYear.IsUnset() {
		t.BirthYear = s.BirthYear.MustGetNull()
	}
	if !s.BirthPlace.IsUnset() {
		t.BirthPlace = s.BirthPlace.MustGetNull()
	}
	if !s.WithersHeight.IsUnset() {
		t.WithersHeight = s.WithersHeight.MustGetNull()
	}
	if !s.Sire.IsUnset() {
		t.Sire = s.Sire.MustGetNull()
	}
	if !s.Dam.IsUnset() {
		t.Dam = s.Dam.MustGetNull()
	}
	if s.IsPregnant.IsValue() {
		t.IsPregnant = s.IsPregnant.MustGet()
	}
	if s.IsDead.IsValue() {
		t.IsDead = s.IsDead.MustGet()
	}
	if !s.Description.IsUnset() {
		t.Description = s.Description.MustGetNull()
	}
	if s.CreatedAt.IsValue() {
		t.CreatedAt = s.CreatedAt.MustGet()
	}
	if s.UpdatedAt.IsValue() {
		t.UpdatedAt = s.UpdatedAt.MustGet()
	}
}

func (s *HorseSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Horses.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 16)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.Herd.IsValue() {
			vals[1] = psql.Arg(s.Herd.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Gender.IsUnset() {
			vals[2] = psql.Arg(s.Gender.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Name.IsUnset() {
			vals[3] = psql.Arg(s.Name.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.BirthDay.IsUnset() {
			vals[4] = psql.Arg(s.BirthDay.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.BirthMonth.IsUnset() {
			vals[5] = psql.Arg(s.BirthMonth.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.BirthYear.IsUnset() {
			vals[6] = psql.Arg(s.BirthYear.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.BirthPlace.IsUnset() {
			vals[7] = psql.Arg(s.BirthPlace.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.WithersHeight.IsUnset() {
			vals[8] = psql.Arg(s.WithersHeight.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Sire.IsUnset() {
			vals[9] = psql.Arg(s.Sire.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Dam.IsUnset() {
			vals[10] = psql.Arg(s.Dam.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.IsPregnant.IsValue() {
			vals[11] = psql.Arg(s.IsPregnant.MustGet())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.IsDead.IsValue() {
			vals[12] = psql.Arg(s.IsDead.MustGet())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Description.IsUnset() {
			vals[13] = psql.Arg(s.Description.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt.IsValue() {
			vals[14] = psql.Arg(s.CreatedAt.MustGet())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.UpdatedAt.IsValue() {
			vals[15] = psql.Arg(s.UpdatedAt.MustGet())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s HorseSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s HorseSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 16)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.Herd.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "herd")...),
			psql.Arg(s.Herd),
		}})
	}

	if !s.Gender.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "gender")...),
			psql.Arg(s.Gender),
		}})
	}

	if !s.Name.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "name")...),
			psql.Arg(s.Name),
		}})
	}

	if !s.BirthDay.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "birth_day")...),
			psql.Arg(s.BirthDay),
		}})
	}

	if !s.BirthMonth.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "birth_month")...),
			psql.Arg(s.BirthMonth),
		}})
	}

	if !s.BirthYear.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "birth_year")...),
			psql.Arg(s.BirthYear),
		}})
	}

	if !s.BirthPlace.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "birth_place")...),
			psql.Arg(s.BirthPlace),
		}})
	}

	if !s.WithersHeight.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "withers_height")...),
			psql.Arg(s.WithersHeight),
		}})
	}

	if !s.Sire.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sire")...),
			psql.Arg(s.Sire),
		}})
	}

	if !s.Dam.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "dam")...),
			psql.Arg(s.Dam),
		}})
	}

	if s.IsPregnant.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_pregnant")...),
			psql.Arg(s.IsPregnant),
		}})
	}

	if s.IsDead.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_dead")...),
			psql.Arg(s.IsDead),
		}})
	}

	if !s.Description.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "description")...),
			psql.Arg(s.Description),
		}})
	}

	if s.CreatedAt.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.UpdatedAt.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated_at")...),
			psql.Arg(s.UpdatedAt),
		}})
	}

	return exprs
}

// FindHorse retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindHorse(ctx context.Context, exec bob.Executor, IDPK uuid.UUID, cols ...string) (*Horse, error) {
	if len(cols) == 0 {
		return Horses.Query(
			sm.Where(Horses.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return Horses.Query(
		sm.Where(Horses.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(Horses.Columns.Only(cols...)),
	).One(ctx, exec)
}

// HorseExists checks the presence of a single record by primary key
func HorseExists(ctx context.Context, exec bob.Executor, IDPK uuid.UUID) (bool, error) {
	return Horses.Query(
		sm.Where(Horses.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Horse is retrieved from the database
func (o *Horse) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Horses.AfterSelectHooks.RunHooks(ctx, exec, HorseSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Horses.AfterInsertHooks.RunHooks(ctx, exec, HorseSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Horses.AfterUpdateHooks.RunHooks(ctx, exec, HorseSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Horses.AfterDeleteHooks.RunHooks(ctx, exec, HorseSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Horse
func (o *Horse) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *Horse) pkEQ() dialect.Expression {
	return psql.Quote("horses", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Horse
func (o *Horse) Update(ctx context.Context, exec bob.Executor, s *HorseSetter) error {
	v, err := Horses.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Horse record with an executor
func (o *Horse) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Horses.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Horse using the executor
func (o *Horse) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Horses.Query(
		sm.Where(Horses.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after HorseSlice is retrieved from the database
func (o HorseSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Horses.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Horses.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Horses.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Horses.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o HorseSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("horses", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o HorseSlice) copyMatchingRows(from ...*Horse) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o HorseSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Horses.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Horse:
				o.copyMatchingRows(retrieved)
			case []*Horse:
				o.copyMatchingRows(retrieved...)
			case HorseSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Horse or a slice of Horse
				// then run the AfterUpdateHooks on the slice
				_, err = Horses.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o HorseSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Horses.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Horse:
				o.copyMatchingRows(retrieved)
			case []*Horse:
				o.copyMatchingRows(retrieved...)
			case HorseSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Horse or a slice of Horse
				// then run the AfterDeleteHooks on the slice
				_, err = Horses.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o HorseSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals HorseSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Horses.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o HorseSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Horses.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o HorseSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Horses.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// HorseBreeds starts a query for related objects on horse_breed
func (o *Horse) HorseBreeds(mods ...bob.Mod[*dialect.SelectQuery]) HorseBreedsQuery {
	return HorseBreeds.Query(append(mods,
		sm.Where(HorseBreeds.Columns.Horse.EQ(psql.Arg(o.ID))),
	)...)
}

func (os HorseSlice) HorseBreeds(mods ...bob.Mod[*dialect.SelectQuery]) HorseBreedsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return HorseBreeds.Query(append(mods,
		sm.Where(psql.Group(HorseBreeds.Columns.Horse).OP("IN", PKArgExpr)),
	)...)
}

// Colors starts a query for related objects on colors
func (o *Horse) Colors(mods ...bob.Mod[*dialect.SelectQuery]) ColorsQuery {
	return Colors.Query(append(mods,
		sm.InnerJoin(HorseColors.NameAs()).On(
			Colors.Columns.ID.EQ(HorseColors.Columns.Color)),
		sm.Where(HorseColors.Columns.Horse.EQ(psql.Arg(o.ID))),
	)...)
}

func (os HorseSlice) Colors(mods ...bob.Mod[*dialect.SelectQuery]) ColorsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Colors.Query(append(mods,
		sm.InnerJoin(HorseColors.NameAs()).On(
			Colors.Columns.ID.EQ(HorseColors.Columns.Color),
		),
		sm.Where(psql.Group(HorseColors.Columns.Horse).OP("IN", PKArgExpr)),
	)...)
}

// GeneticMarkers starts a query for related objects on genetic_markers
func (o *Horse) GeneticMarkers(mods ...bob.Mod[*dialect.SelectQuery]) GeneticMarkersQuery {
	return GeneticMarkers.Query(append(mods,
		sm.InnerJoin(HorseGeneticMarkers.NameAs()).On(
			GeneticMarkers.Columns.ID.EQ(HorseGeneticMarkers.Columns.Marker)),
		sm.Where(HorseGeneticMarkers.Columns.Horse.EQ(psql.Arg(o.ID))),
	)...)
}

func (os HorseSlice) GeneticMarkers(mods ...bob.Mod[*dialect.SelectQuery]) GeneticMarkersQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return GeneticMarkers.Query(append(mods,
		sm.InnerJoin(HorseGeneticMarkers.NameAs()).On(
			GeneticMarkers.Columns.ID.EQ(HorseGeneticMarkers.Columns.Marker),
		),
		sm.Where(psql.Group(HorseGeneticMarkers.Columns.Horse).OP("IN", PKArgExpr)),
	)...)
}

// BirthPlaceBirthplace starts a query for related objects on birthplaces
func (o *Horse) BirthPlaceBirthplace(mods ...bob.Mod[*dialect.SelectQuery]) BirthplacesQuery {
	return Birthplaces.Query(append(mods,
		sm.Where(Birthplaces.Columns.ID.EQ(psql.Arg(o.BirthPlace))),
	)...)
}

func (os HorseSlice) BirthPlaceBirthplace(mods ...bob.Mod[*dialect.SelectQuery]) BirthplacesQuery {
	pkBirthPlace := make(pgtypes.Array[null.Val[uuid.UUID]], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkBirthPlace = append(pkBirthPlace, o.BirthPlace)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkBirthPlace), "uuid[]")),
	))

	return Birthplaces.Query(append(mods,
		sm.Where(psql.Group(Birthplaces.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// Gender starts a query for related objects on genders
func (o *Horse) RelatedGender(mods ...bob.Mod[*dialect.SelectQuery]) GendersQuery {
	return Genders.Query(append(mods,
		sm.Where(Genders.Columns.ID.EQ(psql.Arg(o.Gender))),
	)...)
}

func (os HorseSlice) RelatedGender(mods ...bob.Mod[*dialect.SelectQuery]) GendersQuery {
	pkGender := make(pgtypes.Array[null.Val[uuid.UUID]], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkGender = append(pkGender, o.Gender)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkGender), "uuid[]")),
	))

	return Genders.Query(append(mods,
		sm.Where(psql.Group(Genders.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// Dam starts a query for related objects on horses
func (o *Horse) RelatedDam(mods ...bob.Mod[*dialect.SelectQuery]) HorsesQuery {
	return Horses.Query(append(mods,
		sm.Where(Horses.Columns.ID.EQ(psql.Arg(o.Dam))),
	)...)
}

func (os HorseSlice) RelatedDam(mods ...bob.Mod[*dialect.SelectQuery]) HorsesQuery {
	pkDam := make(pgtypes.Array[null.Val[uuid.UUID]], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkDam = append(pkDam, o.Dam)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkDam), "uuid[]")),
	))

	return Horses.Query(append(mods,
		sm.Where(psql.Group(Horses.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// ReverseDams starts a query for related objects on horses
func (o *Horse) ReverseDams(mods ...bob.Mod[*dialect.SelectQuery]) HorsesQuery {
	return Horses.Query(append(mods,
		sm.Where(Horses.Columns.Dam.EQ(psql.Arg(o.ID))),
	)...)
}

func (os HorseSlice) ReverseDams(mods ...bob.Mod[*dialect.SelectQuery]) HorsesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Horses.Query(append(mods,
		sm.Where(psql.Group(Horses.Columns.Dam).OP("IN", PKArgExpr)),
	)...)
}

// Sire starts a query for related objects on horses
func (o *Horse) RelatedSire(mods ...bob.Mod[*dialect.SelectQuery]) HorsesQuery {
	return Horses.Query(append(mods,
		sm.Where(Horses.Columns.ID.EQ(psql.Arg(o.Sire))),
	)...)
}

func (os HorseSlice) RelatedSire(mods ...bob.Mod[*dialect.SelectQuery]) HorsesQuery {
	pkSire := make(pgtypes.Array[null.Val[uuid.UUID]], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkSire = append(pkSire, o.Sire)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkSire), "uuid[]")),
	))

	return Horses.Query(append(mods,
		sm.Where(psql.Group(Horses.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// ReverseSires starts a query for related objects on horses
func (o *Horse) ReverseSires(mods ...bob.Mod[*dialect.SelectQuery]) HorsesQuery {
	return Horses.Query(append(mods,
		sm.Where(Horses.Columns.Sire.EQ(psql.Arg(o.ID))),
	)...)
}

func (os HorseSlice) ReverseSires(mods ...bob.Mod[*dialect.SelectQuery]) HorsesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Horses.Query(append(mods,
		sm.Where(psql.Group(Horses.Columns.Sire).OP("IN", PKArgExpr)),
	)...)
}

func insertHorseHorseBreeds0(ctx context.Context, exec bob.Executor, horseBreeds1 []*HorseBreedSetter, horse0 *Horse) (HorseBreedSlice, error) {
	for i := range horseBreeds1 {
		horseBreeds1[i].Horse = omit.From(horse0.ID)
	}

	ret, err := HorseBreeds.Insert(bob.ToMods(horseBreeds1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertHorseHorseBreeds0: %w", err)
	}

	return ret, nil
}

func attachHorseHorseBreeds0(ctx context.Context, exec bob.Executor, count int, horseBreeds1 HorseBreedSlice, horse0 *Horse) (HorseBreedSlice, error) {
	setter := &HorseBreedSetter{
		Horse: omit.From(horse0.ID),
	}

	err := horseBreeds1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachHorseHorseBreeds0: %w", err)
	}

	return horseBreeds1, nil
}

func (horse0 *Horse) InsertHorseBreeds(ctx context.Context, exec bob.Executor, related ...*HorseBreedSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	horseBreeds1, err := insertHorseHorseBreeds0(ctx, exec, related, horse0)
	if err != nil {
		return err
	}

	horse0.R.HorseBreeds = append(horse0.R.HorseBreeds, horseBreeds1...)

	for _, rel := range horseBreeds1 {
		rel.R.Horse = horse0
	}
	return nil
}

func (horse0 *Horse) AttachHorseBreeds(ctx context.Context, exec bob.Executor, related ...*HorseBreed) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	horseBreeds1 := HorseBreedSlice(related)

	_, err = attachHorseHorseBreeds0(ctx, exec, len(related), horseBreeds1, horse0)
	if err != nil {
		return err
	}

	horse0.R.HorseBreeds = append(horse0.R.HorseBreeds, horseBreeds1...)

	for _, rel := range related {
		rel.R.Horse = horse0
	}

	return nil
}

func attachHorseColors0(ctx context.Context, exec bob.Executor, count int, horse0 *Horse, colors2 ColorSlice) (HorseColorSlice, error) {
	setters := make([]*HorseColorSetter, count)
	for i := range count {
		setters[i] = &HorseColorSetter{
			Horse: omit.From(horse0.ID),
			Color: omit.From(colors2[i].ID),
		}
	}

	horseColors1, err := HorseColors.Insert(bob.ToMods(setters...)).All(ctx, exec)
	if err != nil {
		return nil, fmt.Errorf("attachHorseColors0: %w", err)
	}

	return horseColors1, nil
}

func (horse0 *Horse) InsertColors(ctx context.Context, exec bob.Executor, related ...*ColorSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	inserted, err := Colors.Insert(bob.ToMods(related...)).All(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	colors2 := ColorSlice(inserted)

	_, err = attachHorseColors0(ctx, exec, len(related), horse0, colors2)
	if err != nil {
		return err
	}

	horse0.R.Colors = append(horse0.R.Colors, colors2...)

	for _, rel := range colors2 {
		rel.R.Horses = append(rel.R.Horses, horse0)
	}
	return nil
}

func (horse0 *Horse) AttachColors(ctx context.Context, exec bob.Executor, related ...*Color) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	colors2 := ColorSlice(related)

	_, err = attachHorseColors0(ctx, exec, len(related), horse0, colors2)
	if err != nil {
		return err
	}

	horse0.R.Colors = append(horse0.R.Colors, colors2...)

	for _, rel := range related {
		rel.R.Horses = append(rel.R.Horses, horse0)
	}

	return nil
}

func attachHorseGeneticMarkers0(ctx context.Context, exec bob.Executor, count int, horse0 *Horse, geneticMarkers2 GeneticMarkerSlice) (HorseGeneticMarkerSlice, error) {
	setters := make([]*HorseGeneticMarkerSetter, count)
	for i := range count {
		setters[i] = &HorseGeneticMarkerSetter{
			Horse:  omit.From(horse0.ID),
			Marker: omit.From(geneticMarkers2[i].ID),
		}
	}

	horseGeneticMarkers1, err := HorseGeneticMarkers.Insert(bob.ToMods(setters...)).All(ctx, exec)
	if err != nil {
		return nil, fmt.Errorf("attachHorseGeneticMarkers0: %w", err)
	}

	return horseGeneticMarkers1, nil
}

func (horse0 *Horse) InsertGeneticMarkers(ctx context.Context, exec bob.Executor, related ...*GeneticMarkerSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	inserted, err := GeneticMarkers.Insert(bob.ToMods(related...)).All(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	geneticMarkers2 := GeneticMarkerSlice(inserted)

	_, err = attachHorseGeneticMarkers0(ctx, exec, len(related), horse0, geneticMarkers2)
	if err != nil {
		return err
	}

	horse0.R.GeneticMarkers = append(horse0.R.GeneticMarkers, geneticMarkers2...)

	for _, rel := range geneticMarkers2 {
		rel.R.Horses = append(rel.R.Horses, horse0)
	}
	return nil
}

func (horse0 *Horse) AttachGeneticMarkers(ctx context.Context, exec bob.Executor, related ...*GeneticMarker) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	geneticMarkers2 := GeneticMarkerSlice(related)

	_, err = attachHorseGeneticMarkers0(ctx, exec, len(related), horse0, geneticMarkers2)
	if err != nil {
		return err
	}

	horse0.R.GeneticMarkers = append(horse0.R.GeneticMarkers, geneticMarkers2...)

	for _, rel := range related {
		rel.R.Horses = append(rel.R.Horses, horse0)
	}

	return nil
}

func attachHorseBirthPlaceBirthplace0(ctx context.Context, exec bob.Executor, count int, horse0 *Horse, birthplace1 *Birthplace) (*Horse, error) {
	setter := &HorseSetter{
		BirthPlace: omitnull.From(birthplace1.ID),
	}

	err := horse0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachHorseBirthPlaceBirthplace0: %w", err)
	}

	return horse0, nil
}

func (horse0 *Horse) InsertBirthPlaceBirthplace(ctx context.Context, exec bob.Executor, related *BirthplaceSetter) error {
	var err error

	birthplace1, err := Birthplaces.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachHorseBirthPlaceBirthplace0(ctx, exec, 1, horse0, birthplace1)
	if err != nil {
		return err
	}

	horse0.R.BirthPlaceBirthplace = birthplace1

	birthplace1.R.BirthPlaceHorses = append(birthplace1.R.BirthPlaceHorses, horse0)

	return nil
}

func (horse0 *Horse) AttachBirthPlaceBirthplace(ctx context.Context, exec bob.Executor, birthplace1 *Birthplace) error {
	var err error

	_, err = attachHorseBirthPlaceBirthplace0(ctx, exec, 1, horse0, birthplace1)
	if err != nil {
		return err
	}

	horse0.R.BirthPlaceBirthplace = birthplace1

	birthplace1.R.BirthPlaceHorses = append(birthplace1.R.BirthPlaceHorses, horse0)

	return nil
}

func attachHorseGender0(ctx context.Context, exec bob.Executor, count int, horse0 *Horse, gender1 *Gender) (*Horse, error) {
	setter := &HorseSetter{
		Gender: omitnull.From(gender1.ID),
	}

	err := horse0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachHorseGender0: %w", err)
	}

	return horse0, nil
}

func (horse0 *Horse) InsertGender(ctx context.Context, exec bob.Executor, related *GenderSetter) error {
	var err error

	gender1, err := Genders.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachHorseGender0(ctx, exec, 1, horse0, gender1)
	if err != nil {
		return err
	}

	horse0.R.Gender = gender1

	gender1.R.Horses = append(gender1.R.Horses, horse0)

	return nil
}

func (horse0 *Horse) AttachGender(ctx context.Context, exec bob.Executor, gender1 *Gender) error {
	var err error

	_, err = attachHorseGender0(ctx, exec, 1, horse0, gender1)
	if err != nil {
		return err
	}

	horse0.R.Gender = gender1

	gender1.R.Horses = append(gender1.R.Horses, horse0)

	return nil
}

func attachHorseDam0(ctx context.Context, exec bob.Executor, count int, horse0 *Horse, horse1 *Horse) (*Horse, error) {
	setter := &HorseSetter{
		Dam: omitnull.From(horse1.ID),
	}

	err := horse0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachHorseDam0: %w", err)
	}

	return horse0, nil
}

func (horse0 *Horse) InsertDam(ctx context.Context, exec bob.Executor, related *HorseSetter) error {
	var err error

	horse1, err := Horses.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachHorseDam0(ctx, exec, 1, horse0, horse1)
	if err != nil {
		return err
	}

	horse0.R.Dam = horse1

	horse1.R.Dam = horse0

	return nil
}

func (horse0 *Horse) AttachDam(ctx context.Context, exec bob.Executor, horse1 *Horse) error {
	var err error

	_, err = attachHorseDam0(ctx, exec, 1, horse0, horse1)
	if err != nil {
		return err
	}

	horse0.R.Dam = horse1

	horse1.R.Dam = horse0

	return nil
}

func insertHorseReverseDams0(ctx context.Context, exec bob.Executor, horses1 []*HorseSetter, horse0 *Horse) (HorseSlice, error) {
	for i := range horses1 {
		horses1[i].Dam = omitnull.From(horse0.ID)
	}

	ret, err := Horses.Insert(bob.ToMods(horses1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertHorseReverseDams0: %w", err)
	}

	return ret, nil
}

func attachHorseReverseDams0(ctx context.Context, exec bob.Executor, count int, horses1 HorseSlice, horse0 *Horse) (HorseSlice, error) {
	setter := &HorseSetter{
		Dam: omitnull.From(horse0.ID),
	}

	err := horses1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachHorseReverseDams0: %w", err)
	}

	return horses1, nil
}

func (horse0 *Horse) InsertReverseDams(ctx context.Context, exec bob.Executor, related ...*HorseSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	horses1, err := insertHorseReverseDams0(ctx, exec, related, horse0)
	if err != nil {
		return err
	}

	horse0.R.ReverseDams = append(horse0.R.ReverseDams, horses1...)

	for _, rel := range horses1 {
		rel.R.ReverseDams = append(rel.R.ReverseDams, horse0)
	}
	return nil
}

func (horse0 *Horse) AttachReverseDams(ctx context.Context, exec bob.Executor, related ...*Horse) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	horses1 := HorseSlice(related)

	_, err = attachHorseReverseDams0(ctx, exec, len(related), horses1, horse0)
	if err != nil {
		return err
	}

	horse0.R.ReverseDams = append(horse0.R.ReverseDams, horses1...)

	for _, rel := range related {
		rel.R.ReverseDams = append(rel.R.ReverseDams, horse0)
	}

	return nil
}

func attachHorseSire0(ctx context.Context, exec bob.Executor, count int, horse0 *Horse, horse1 *Horse) (*Horse, error) {
	setter := &HorseSetter{
		Sire: omitnull.From(horse1.ID),
	}

	err := horse0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachHorseSire0: %w", err)
	}

	return horse0, nil
}

func (horse0 *Horse) InsertSire(ctx context.Context, exec bob.Executor, related *HorseSetter) error {
	var err error

	horse1, err := Horses.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachHorseSire0(ctx, exec, 1, horse0, horse1)
	if err != nil {
		return err
	}

	horse0.R.Sire = horse1

	horse1.R.Sire = horse0

	return nil
}

func (horse0 *Horse) AttachSire(ctx context.Context, exec bob.Executor, horse1 *Horse) error {
	var err error

	_, err = attachHorseSire0(ctx, exec, 1, horse0, horse1)
	if err != nil {
		return err
	}

	horse0.R.Sire = horse1

	horse1.R.Sire = horse0

	return nil
}

func insertHorseReverseSires0(ctx context.Context, exec bob.Executor, horses1 []*HorseSetter, horse0 *Horse) (HorseSlice, error) {
	for i := range horses1 {
		horses1[i].Sire = omitnull.From(horse0.ID)
	}

	ret, err := Horses.Insert(bob.ToMods(horses1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertHorseReverseSires0: %w", err)
	}

	return ret, nil
}

func attachHorseReverseSires0(ctx context.Context, exec bob.Executor, count int, horses1 HorseSlice, horse0 *Horse) (HorseSlice, error) {
	setter := &HorseSetter{
		Sire: omitnull.From(horse0.ID),
	}

	err := horses1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachHorseReverseSires0: %w", err)
	}

	return horses1, nil
}

func (horse0 *Horse) InsertReverseSires(ctx context.Context, exec bob.Executor, related ...*HorseSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	horses1, err := insertHorseReverseSires0(ctx, exec, related, horse0)
	if err != nil {
		return err
	}

	horse0.R.ReverseSires = append(horse0.R.ReverseSires, horses1...)

	for _, rel := range horses1 {
		rel.R.ReverseSires = append(rel.R.ReverseSires, horse0)
	}
	return nil
}

func (horse0 *Horse) AttachReverseSires(ctx context.Context, exec bob.Executor, related ...*Horse) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	horses1 := HorseSlice(related)

	_, err = attachHorseReverseSires0(ctx, exec, len(related), horses1, horse0)
	if err != nil {
		return err
	}

	horse0.R.ReverseSires = append(horse0.R.ReverseSires, horses1...)

	for _, rel := range related {
		rel.R.ReverseSires = append(rel.R.ReverseSires, horse0)
	}

	return nil
}
